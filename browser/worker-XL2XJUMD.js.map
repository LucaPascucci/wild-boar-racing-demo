{
  "version": 3,
  "sources": ["src/app/driver/model/driver.ts", "node_modules/date-fns/constants.js", "node_modules/date-fns/minutesToMilliseconds.js", "src/app/driver/service/driver.worker.ts"],
  "sourcesContent": ["export interface Driver {\n  id: number;\n  name: string;\n  surname: string;\n  raceName: string;\n}\n\nexport function deserializeDriverDTO(data: any): Driver {\n  return {\n    id: data.id,\n    name: data.name,\n    surname: data.surname,\n    raceName: data.raceName\n  };\n}\n\nexport function deserializeDriversDTO(data: any[]): Driver[] {\n  return data.map(item => deserializeDriverDTO(item));\n}\n", "/**\n * @module constants\n * @summary Useful constants\n * @description\n * Collection of useful date constants.\n *\n * The constants could be imported from `date-fns/constants`:\n *\n * ```ts\n * import { maxTime, minTime } from \"./constants/date-fns/constants\";\n *\n * function isAllowedTime(time) {\n *   return time <= maxTime && time >= minTime;\n * }\n * ```\n */\n\n/**\n * @constant\n * @name daysInWeek\n * @summary Days in 1 week.\n */\nexport const daysInWeek = 7;\n\n/**\n * @constant\n * @name daysInYear\n * @summary Days in 1 year.\n *\n * @description\n * How many days in a year.\n *\n * One years equals 365.2425 days according to the formula:\n *\n * > Leap year occurs every 4 years, except for years that are divisible by 100 and not divisible by 400.\n * > 1 mean year = (365+1/4-1/100+1/400) days = 365.2425 days\n */\nexport const daysInYear = 365.2425;\n\n/**\n * @constant\n * @name maxTime\n * @summary Maximum allowed time.\n *\n * @example\n * import { maxTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = 8640000000000001 <= maxTime;\n * //=> false\n *\n * new Date(8640000000000001);\n * //=> Invalid Date\n */\nexport const maxTime = Math.pow(10, 8) * 24 * 60 * 60 * 1000;\n\n/**\n * @constant\n * @name minTime\n * @summary Minimum allowed time.\n *\n * @example\n * import { minTime } from \"./constants/date-fns/constants\";\n *\n * const isValid = -8640000000000001 >= minTime;\n * //=> false\n *\n * new Date(-8640000000000001)\n * //=> Invalid Date\n */\nexport const minTime = -maxTime;\n\n/**\n * @constant\n * @name millisecondsInWeek\n * @summary Milliseconds in 1 week.\n */\nexport const millisecondsInWeek = 604800000;\n\n/**\n * @constant\n * @name millisecondsInDay\n * @summary Milliseconds in 1 day.\n */\nexport const millisecondsInDay = 86400000;\n\n/**\n * @constant\n * @name millisecondsInMinute\n * @summary Milliseconds in 1 minute\n */\nexport const millisecondsInMinute = 60000;\n\n/**\n * @constant\n * @name millisecondsInHour\n * @summary Milliseconds in 1 hour\n */\nexport const millisecondsInHour = 3600000;\n\n/**\n * @constant\n * @name millisecondsInSecond\n * @summary Milliseconds in 1 second\n */\nexport const millisecondsInSecond = 1000;\n\n/**\n * @constant\n * @name minutesInYear\n * @summary Minutes in 1 year.\n */\nexport const minutesInYear = 525600;\n\n/**\n * @constant\n * @name minutesInMonth\n * @summary Minutes in 1 month.\n */\nexport const minutesInMonth = 43200;\n\n/**\n * @constant\n * @name minutesInDay\n * @summary Minutes in 1 day.\n */\nexport const minutesInDay = 1440;\n\n/**\n * @constant\n * @name minutesInHour\n * @summary Minutes in 1 hour.\n */\nexport const minutesInHour = 60;\n\n/**\n * @constant\n * @name monthsInQuarter\n * @summary Months in 1 quarter.\n */\nexport const monthsInQuarter = 3;\n\n/**\n * @constant\n * @name monthsInYear\n * @summary Months in 1 year.\n */\nexport const monthsInYear = 12;\n\n/**\n * @constant\n * @name quartersInYear\n * @summary Quarters in 1 year\n */\nexport const quartersInYear = 4;\n\n/**\n * @constant\n * @name secondsInHour\n * @summary Seconds in 1 hour.\n */\nexport const secondsInHour = 3600;\n\n/**\n * @constant\n * @name secondsInMinute\n * @summary Seconds in 1 minute.\n */\nexport const secondsInMinute = 60;\n\n/**\n * @constant\n * @name secondsInDay\n * @summary Seconds in 1 day.\n */\nexport const secondsInDay = secondsInHour * 24;\n\n/**\n * @constant\n * @name secondsInWeek\n * @summary Seconds in 1 week.\n */\nexport const secondsInWeek = secondsInDay * 7;\n\n/**\n * @constant\n * @name secondsInYear\n * @summary Seconds in 1 year.\n */\nexport const secondsInYear = secondsInDay * daysInYear;\n\n/**\n * @constant\n * @name secondsInMonth\n * @summary Seconds in 1 month\n */\nexport const secondsInMonth = secondsInYear / 12;\n\n/**\n * @constant\n * @name secondsInQuarter\n * @summary Seconds in 1 quarter.\n */\nexport const secondsInQuarter = secondsInMonth * 3;\n\n/**\n * @constant\n * @name constructFromSymbol\n * @summary Symbol enabling Date extensions to inherit properties from the reference date.\n *\n * The symbol is used to enable the `constructFrom` function to construct a date\n * using a reference date and a value. It allows to transfer extra properties\n * from the reference date to the new date. It's useful for extensions like\n * [`TZDate`](https://github.com/date-fns/tz) that accept a time zone as\n * a constructor argument.\n */\nexport const constructFromSymbol = Symbol.for(\"constructDateFrom\");\n", "import { millisecondsInMinute } from \"./constants.js\";\n\n/**\n * @name minutesToMilliseconds\n * @category Conversion Helpers\n * @summary Convert minutes to milliseconds.\n *\n * @description\n * Convert a number of minutes to a full number of milliseconds.\n *\n * @param minutes - The number of minutes to be converted\n *\n * @returns The number of minutes converted in milliseconds\n *\n * @example\n * // Convert 2 minutes to milliseconds\n * const result = minutesToMilliseconds(2)\n * //=> 120000\n */\nexport function minutesToMilliseconds(minutes) {\n  return Math.trunc(minutes * millisecondsInMinute);\n}\n\n// Fallback for modularized imports:\nexport default minutesToMilliseconds;\n", "/// <reference lib=\"webworker\" />\n\nimport { Stint } from \"../../stint/model/stint\";\nimport { deserializeDriversDTO, Driver } from \"../model/driver\";\nimport { minutesToMilliseconds } from \"date-fns\";\nimport { DriverConfig } from \"../model/driver-config\";\nimport { Lap } from '../../lap/model/lap';\n\naddEventListener('message', ({ data }) => {\n  const drivers = deserializeDriversDTO(data.drivers);\n  const stints = data.stints as Stint[];\n  const driverConfig = data.driverConfig as DriverConfig;\n  const validTeamPaceLaps = data.validTeamPaceLaps as Lap[];\n\n  const driversTimeOnTrackMap = createDriverTrackTimeMap(stints, drivers);\n  const driversTimeOnTrackWarningMap = createDriversTimeOnTrackWarningMap(driversTimeOnTrackMap, driverConfig);\n  const driversStintCountMap= createDriverStintCountMap(stints, drivers);\n  const driverWithMoreTimeFromLastStint= getDriverWithMoreTimeFromLastStint(stints, drivers);\n  const driversTimeFromLastStintMap = createDriversTimeFromLastStintMap(stints, drivers);\n  const raceNameById = new Map(drivers.map(driver => [driver.id, driver.raceName]));\n  const driverPaceById = calculateDriverPaceById(validTeamPaceLaps);\n  const driverBestLapById = getDriverBestLapById(validTeamPaceLaps);\n  const driverIdBestPace = getDriverBestPace(driverPaceById);\n  const driverBestPaceMillisecond = driverIdBestPace !== undefined ? driverPaceById.get(driverIdBestPace) : undefined;\n  const driversTimeOnTrackWarningCount = getDriversTimeOnTrackWarningCount(driversTimeOnTrackWarningMap);\n  const driverLastStintIdByDriverId = getDriverLastStintIdByDriverId(stints, drivers);\n\n  postMessage({\n    driversTimeOnTrackMap: driversTimeOnTrackMap,\n    driversTimeOnTrackWarningMap: driversTimeOnTrackWarningMap,\n    driversStintCountMap: driversStintCountMap,\n    driverWithMoreTimeFromLastStint: driverWithMoreTimeFromLastStint,\n    driversTimeFromLastStintMap: driversTimeFromLastStintMap,\n    raceNameById: raceNameById,\n    driverPaceById: driverPaceById,\n    driverBestLapById: driverBestLapById,\n    driverIdBestPace: driverIdBestPace,\n    driverBestPaceMillisecond: driverBestPaceMillisecond,\n    driversTimeOnTrackWarningCount: driversTimeOnTrackWarningCount,\n    driverLastStintIdByDriverId: driverLastStintIdByDriverId\n  });\n});\n\nfunction createDriverTrackTimeMap(stints: Stint[], drivers: Driver[]): Map<number, number> {\n  const result = new Map<number, number>();\n  const currentTime = new Date().getTime(); // Cache current time to avoid multiple Date() calls\n\n  // Initialize all drivers with 0 time\n  for (const driver of drivers) {\n    result.set(driver.id, 0);\n  }\n\n  // Calculate time spent for each stint\n  for (const stint of stints) {\n    const timeSpent = stint.endedAt\n      ? stint.endedAt.getTime() - stint.startedAt.getTime()\n      : currentTime - stint.startedAt.getTime(); // Use cached current time\n\n    // Accumulate time for the driver (we know the driver exists from initialization)\n    result.set(stint.driverId, result.get(stint.driverId)! + timeSpent);\n  }\n\n  return result;\n}\n\nfunction createDriversTimeOnTrackWarningMap(\n    driverTrackTimeMap: Map<number, number>,\n    driverConfig: DriverConfig\n): Map<number, boolean> {\n  const result = new Map<number, boolean>();\n\n  const minDriverOnTrackMillis = minutesToMilliseconds(driverConfig.minDriverOnTrackMinute);\n  const maxDriverOnTrackMillis = minutesToMilliseconds(driverConfig.maxDriverOnTrackMinute);\n  const warningThresholdMillis = minutesToMilliseconds(driverConfig.warningDriverOnTrackThresholdMinute);\n\n  driverTrackTimeMap.forEach((timeOnTrack, driverId) => {\n    const isBelowMin = timeOnTrack < minDriverOnTrackMillis;\n    const isNearMax = (maxDriverOnTrackMillis - timeOnTrack) <= warningThresholdMillis;\n    result.set(driverId, isBelowMin || isNearMax);\n  });\n\n  return result;\n}\n\nfunction getDriversTimeOnTrackWarningCount(driversTimeOnTrackWarningMap :Map<number, boolean>): number {\n  let warningCount = 0;\n  driversTimeOnTrackWarningMap.forEach((isWarning) => {\n    if (isWarning) {\n      warningCount++;\n    }\n  });\n  return warningCount;\n}\n\nfunction createDriverStintCountMap(stints: Stint[], drivers: Driver[]): Map<number, number> {\n  const result = new Map<number, number>();\n\n  drivers.forEach(driver => {\n    result.set(driver.id, 0);\n  });\n\n  // Count the number of stints for each driver\n  stints.forEach(stint => {\n    if (result.has(stint.driverId)) {\n      result.set(stint.driverId, result.get(stint.driverId)! + 1);\n    } else {\n      result.set(stint.driverId, 1);\n    }\n  });\n\n  return result;\n}\n\nfunction getDriverWithMoreTimeFromLastStint(stints: Stint[], drivers: Driver[]): Driver | undefined {\n  if (drivers.length === 0) {\n    return undefined;\n  }\n  let result: Driver | undefined = undefined;\n\n  const driversFromLastStintMap = createDriversTimeFromLastStintMap(stints, drivers);\n\n  // Find the driver currently on track\n  const currentDriverId = stints.find(stint => stint.endedAt === null)?.driverId;\n\n  // Find the driver with the least time on track, excluding the current driver\n  const driverMap = new Map(drivers.map(driver => [driver.id, driver]));\n  let maxTime = -1;\n  let hasZeroTimeDriver = false;\n\n  driversFromLastStintMap.forEach((timeFromLastStint, driverId) => {\n    if (driverId !== currentDriverId) {\n      if (timeFromLastStint === 0) {\n        // Prioritize drivers with timeFromLastStint = 0\n        if (!hasZeroTimeDriver || (hasZeroTimeDriver && timeFromLastStint > maxTime)) {\n          maxTime = timeFromLastStint;\n          result = driverMap.get(driverId);\n          hasZeroTimeDriver = true;\n        }\n      } else if (!hasZeroTimeDriver && timeFromLastStint > maxTime) {\n        // Consider drivers with timeFromLastStint > 0 only if no zero-time driver has been found\n        maxTime = timeFromLastStint;\n        result = driverMap.get(driverId);\n      }\n    }\n  });\n\n  return result;\n}\n\nfunction createDriversTimeFromLastStintMap(stints: Stint[], drivers: Driver[]): Map<number, number> {\n  const result = new Map<number, number>();\n\n  drivers.forEach(driver => {\n    const lastDriverStint = stints.filter(stint => stint.driverId === driver.id)\n    .sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime())\n    .at(0);\n\n    if (lastDriverStint) {\n      if (lastDriverStint.endedAt) {\n        result.set(driver.id, new Date().getTime() - lastDriverStint.endedAt.getTime());\n      } else {\n        result.set(driver.id, 0);\n      }\n    } else {\n      result.set(driver.id, 0);\n    }\n  });\n\n  // prendere lo stint pi\u00F9 recente di ogni driver e calcolare la sua distanza (millisecondi) da ora, impostare 0 se lo stint attivo (con endDate uguale a null)\n  return result;\n}\n\nfunction calculateDriverPaceById(validTeamPaceLaps: Lap[]): Map<number, number> {\n  const result = new Map<number, number>();\n  const driverLapsMap = new Map<number, number[]>();\n\n  // Group laps by driver ID for efficient processing\n  validTeamPaceLaps.forEach(lap => {\n    if (!driverLapsMap.has(lap.driverId)) {\n      driverLapsMap.set(lap.driverId, []);\n    }\n    driverLapsMap.get(lap.driverId)!.push(lap.lapMilliseconds);\n  });\n\n  // Calculate average pace for each driver\n  driverLapsMap.forEach((lapTimes, driverId) => {\n    if (lapTimes.length > 0) {\n      const totalTime = lapTimes.reduce((sum, time) => sum + time, 0);\n      const averagePace = Math.round(totalTime / lapTimes.length);\n      result.set(driverId, averagePace);\n    }\n  });\n\n  return result;\n}\n\nfunction getDriverBestLapById(validTeamPaceLaps: Lap[]): Map<number, number> {\n  const result = new Map<number, number>();\n\n  // Group laps by driver ID and find the minimum lap time for each driver\n  validTeamPaceLaps.forEach(lap => {\n    const currentBest = result.get(lap.driverId);\n    if (currentBest === undefined || lap.lapMilliseconds < currentBest) {\n      result.set(lap.driverId, lap.lapMilliseconds);\n    }\n  });\n\n  return result;\n}\n\nfunction getDriverBestPace(driverPaceById: Map<number, number>): number | undefined {\n  if (driverPaceById.size === 0) {\n    return undefined;\n  }\n\n  let bestDriverId: number | undefined = undefined;\n  let bestPace = Number.MAX_SAFE_INTEGER;\n\n  // Find the driver with the fastest (minimum) pace\n  for (const [driverId, pace] of driverPaceById) {\n    if (pace < bestPace) {\n      bestPace = pace;\n      bestDriverId = driverId;\n    }\n  }\n\n  return bestDriverId;\n}\n\nfunction getDriverLastStintIdByDriverId(stints: Stint[], drivers: Driver[]): Map<number,number> {\n  const result = new Map<number, number>();\n\n  drivers.forEach(driver => {\n    const lastCompletedDriverStint = stints.filter(stint => stint.driverId === driver.id && stint.endedAt !== null)\n    .sort((a, b) => b.startedAt.getTime() - a.startedAt.getTime())\n    .at(0);\n\n    if (lastCompletedDriverStint) {\n      result.set(driver.id, lastCompletedDriverStint.id);\n    }\n  });\n\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["maxTime"]
}
