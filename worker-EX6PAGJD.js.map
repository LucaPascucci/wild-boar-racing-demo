{
  "version": 3,
  "sources": ["src/app/lap/service/lap.worker.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\n\nimport { Lap } from \"../model/lap\";\nimport { LapConfig } from \"../model/lap-config\";\nimport { Team } from '../../team/model/team';\n\naddEventListener('message', ({ data }) => {\n  const lapConfig = data.lapConfig as LapConfig;\n  const laps = data.laps as Map<number, Lap>;\n  const activeTeam = data.activeTeam as Team | undefined;\n\n  const lapsArray = [...laps.values()];\n  const pitLaps = lapsArray.filter(lap => lap.pitStop);\n\n  const paceLapThresholdMilliseconds = lapConfig.paceLapThresholdMilliseconds;\n  const paceLapNumber = lapConfig.paceLapNumber;\n\n  const lapsByRaceNumber = getLapsByRaceNumber(lapsArray);\n  const pacesByRaceNumber = calculatePacesByRaceNumber(lapsArray, paceLapThresholdMilliseconds, paceLapNumber);\n  const validTeamPaceLaps = getValidTeamPaceLaps(lapsArray, paceLapThresholdMilliseconds);\n\n  const gapFirstLapMillisecondsByRaceNumber = calculateGapFirstLapMillisecondsByRaceNumber(lapsArray);\n\n  const cumulatedTimeByRaceNumber = calculateCumulatedTimeByRaceNumber(\n    lapsByRaceNumber,\n    gapFirstLapMillisecondsByRaceNumber\n  );\n  const lastLapNumberByRaceNumber = getLastLapNumberByRaceNumber(lapsByRaceNumber);\n\n  const teamBestLap = getTeamBestLap(validTeamPaceLaps);\n  const lastTeamLap = getLastTeamLap(lapsArray, activeTeam);\n  const lastTeamLapDeltaMilliseconds = getLastTeamLapDeltaMilliseconds(lapsArray, lastTeamLap, activeTeam);\n\n  postMessage({\n    pacesByRaceNumber: pacesByRaceNumber,\n    cumulatedTimeByRaceNumber: cumulatedTimeByRaceNumber,\n    lastLapNumberByRaceNumber: lastLapNumberByRaceNumber,\n    validTeamPaceLaps: validTeamPaceLaps,\n    teamBestLap: teamBestLap,\n    lastTeamLap: lastTeamLap,\n    lastTeamLapDeltaMilliseconds: lastTeamLapDeltaMilliseconds,\n    pitLaps: pitLaps,\n  });\n});\n\nfunction getLastLapNumberByRaceNumber(lapsByRaceNumber: Map<number, Lap[]>): Map<number, number> {\n  const result = new Map<number, number>();\n\n  lapsByRaceNumber.forEach((laps, raceNumber) => {\n    if (laps.length > 0) {\n      const sortedLaps = laps.sort((a, b) => b.lapNumber - a.lapNumber);\n      result.set(raceNumber, sortedLaps[0].lapNumber);\n    }\n  });\n  return result;\n}\n\nfunction calculateCumulatedTimeByRaceNumber(\n  lapsByRaceNumber: Map<number, Lap[]>,\n  gapFirstLapMillisecondsByRaceNumber: Map<number,number>\n): Map<number, number[]> {\n  const result = new Map<number, number[]>();\n\n  // Populate the result map with cumulative lap times for each driver\n  lapsByRaceNumber.forEach((laps, raceNumber) => {\n    // Sort laps by lap number to ensure correct order\n    const sortedLaps = laps.sort((a, b) => a.lapNumber - b.lapNumber);\n\n    const gapFirstLapMilliseconds = gapFirstLapMillisecondsByRaceNumber.get(raceNumber) || 0;\n\n    const cumulativeTimes: number[] = [];\n    cumulativeTimes.push(gapFirstLapMilliseconds);\n    let cumulativeTime = gapFirstLapMilliseconds;\n\n    // Calculate cumulative time for each lap\n    sortedLaps.forEach(lap => {\n      cumulativeTime += lap.lapMilliseconds;\n      cumulativeTimes.push(cumulativeTime);\n    });\n\n    result.set(raceNumber, cumulativeTimes);\n  });\n  return result;\n}\n\nfunction getLapsByRaceNumber(laps: Lap[]): Map<number, Lap[]> {\n  const result = new Map<number, Lap[]>();\n  laps.forEach(lap => {\n    if (!result.has(lap.raceNumber)) {\n      result.set(lap.raceNumber, []);\n    }\n    result.get(lap.raceNumber)?.push(lap);\n  });\n  return result;\n}\n\nfunction calculatePacesByRaceNumber(\n  laps: Lap[],\n  paceLapThresholdMilliseconds: number,\n  paceLapNumber: number,\n): Map<number, number> {\n  // Create a map to store the race pace for each driver\n  const result = new Map<number, number>();\n\n  // Group laps by driver (raceNumber)\n  const lapsByRaceNumber = new Map<number, Lap[]>();\n\n  // Filter out pit stop laps and group by race number\n  laps.filter(lap => !lap.pitStop)\n  .forEach(lap => {\n    if (!lapsByRaceNumber.has(lap.raceNumber)) {\n      lapsByRaceNumber.set(lap.raceNumber, []);\n    }\n    lapsByRaceNumber.get(lap.raceNumber)?.push(lap);\n  });\n\n  // Process each driver's laps\n  lapsByRaceNumber.forEach((driverLaps, raceNumber) => {\n    // Sort laps by lapNumber in descending order to get the most recent ones\n    const sortedLaps = driverLaps\n    .filter(lap => !lap.pitStop && lap.lapMilliseconds < paceLapThresholdMilliseconds)\n    .sort((a, b) => b.lapNumber - a.lapNumber);\n\n    // Take up to four most recent laps\n    const recentLaps = sortedLaps.slice(0, paceLapNumber);\n\n    // Calculate the average lap time if we have at least one lap\n    if (recentLaps.length > 0) {\n      const totalTime = recentLaps.reduce((sum, lap) => sum + lap.lapMilliseconds, 0);\n      const averageTime = Math.round(totalTime / recentLaps.length);\n      result.set(raceNumber, averageTime);\n    }\n  });\n  return result;\n}\n\nfunction getValidTeamPaceLaps(laps: Lap[], paceLapThresholdMilliseconds: number): Lap[] {\n  return laps.filter(lap =>\n    !lap.pitStop &&\n    lap.driverId !== undefined &&\n    lap.driverId !== null &&\n    lap.stintId !== undefined &&\n    lap.stintId !== null &&\n    lap.lapMilliseconds <= paceLapThresholdMilliseconds\n  );\n}\n\nfunction getTeamBestLap(validTeamPaceLaps: Lap[]): Lap | undefined {\n  if (validTeamPaceLaps.length === 0) {\n    return undefined;\n  }\n\n  return validTeamPaceLaps.reduce((bestLap, currentLap) => {\n    return currentLap.lapMilliseconds < bestLap.lapMilliseconds ? currentLap : bestLap;\n  });\n}\n\nfunction getLastTeamLap(laps: Lap[], activeTeam: Team | undefined): Lap | undefined {\n  if (!activeTeam) {\n    return undefined;\n  }\n\n  const teamLaps = laps.filter(lap => lap.raceNumber === activeTeam.raceNumber);\n\n  if (teamLaps.length === 0) {\n    return undefined;\n  }\n\n  return teamLaps.reduce((lastLap, currentLap) => {\n    return currentLap.lapNumber > lastLap.lapNumber ? currentLap : lastLap;\n  });\n}\n\nfunction getLastTeamLapDeltaMilliseconds(laps: Lap[], lastTeamLap: Lap | undefined, activeTeam: Team | undefined): number | undefined {\n  if (!lastTeamLap) {\n    return undefined;\n  }\n\n  if (!activeTeam) {\n    return undefined;\n  }\n\n  if (lastTeamLap.lapNumber === 1) {\n    return undefined;\n  }\n\n  // Trova la penultima lap del team\n  const teamLaps = laps.filter(lap => lap.raceNumber === activeTeam.raceNumber);\n  const sortedTeamLaps = teamLaps.sort((a, b) => b.lapNumber - a.lapNumber);\n\n  if (sortedTeamLaps.length < 2) {\n    return undefined;\n  }\n\n  const previousLap = sortedTeamLaps[1]; // La seconda lap pi\u00F9 recente (penultima)\n\n  // Calcola il delta tra l'ultima e la penultima lap\n  return lastTeamLap.lapMilliseconds - previousLap.lapMilliseconds;\n}\n\nfunction calculateGapFirstLapMillisecondsByRaceNumber(laps: Lap[]): Map<number,number> {\n  const result = new Map<number,number>();\n\n  // Filter only first laps (lapNumber === 1) and group by raceNumber\n  const firstLapsByRaceNumber = laps\n    .filter(lap => lap.lapNumber === 1)\n    .reduce((acc, lap) => {\n      acc.set(lap.raceNumber, lap);\n      return acc;\n    }, new Map<number, Lap>());\n\n  // Find the team in position 1 (leader)\n  const leaderLap = Array.from(firstLapsByRaceNumber.values())\n    .find(lap => lap.position === 1);\n\n  if (!leaderLap) {\n    // If no leader found, return empty result\n    return result;\n  }\n\n  // Calculate gaps relative to the leader\n  // Convert all laps to array and sort by position to calculate cumulative gaps\n  // Filter out laps with undefined position and sort by position\n  const sortedLaps = Array.from(firstLapsByRaceNumber.values())\n    .filter(lap => lap.position !== undefined)\n    .sort((a, b) => a.position! - b.position!);\n\n  // Calculate cumulative gaps from leader\n  let cumulativeGapFromLeader = 0;\n\n  sortedLaps.forEach((lap) => {\n    if (lap.position === 1) {\n      // Leader has 0 gap\n      result.set(lap.raceNumber, 0);\n      cumulativeGapFromLeader = 0;\n    } else if (lap.gap) {\n      // Convert gap string to milliseconds (this is gap to previous position)\n      const gapToPrevious = convertGapToMilliseconds(lap.gap);\n\n      cumulativeGapFromLeader += gapToPrevious;\n      result.set(lap.raceNumber, cumulativeGapFromLeader);\n    } else {\n      // If no gap data available, use previous cumulative gap\n      result.set(lap.raceNumber, cumulativeGapFromLeader);\n    }\n  });\n\n\n  const deltaMillisecondsFromLeader = new Map<number,number>();\n  sortedLaps.forEach((lap) => {\n    if (lap.position === 1) {\n      // Leader has 0 gap\n      deltaMillisecondsFromLeader.set(lap.raceNumber, 0);\n    } else {\n      deltaMillisecondsFromLeader.set(lap.raceNumber, leaderLap.lapMilliseconds - lap.lapMilliseconds);\n    }\n  });\n\n  result.forEach((gap, raceNumber) => {\n    if (deltaMillisecondsFromLeader.has(raceNumber)) {\n      result.set(raceNumber, gap + deltaMillisecondsFromLeader.get(raceNumber)!);\n    }\n  });\n\n  return result;\n}\n\nfunction convertGapToMilliseconds(gapString: string | undefined): number {\n  if (!gapString || gapString.trim() === '') {\n    return 0;\n  }\n\n  // Handle different gap formats\n  const cleanGap = gapString.trim();\n\n  // Check if format includes minutes (minutes:seconds.milliseconds)\n  if (cleanGap.includes(':')) {\n    const [minutesPart, secondsPart] = cleanGap.split(':');\n    const minutes = parseInt(minutesPart, 10);\n\n    // Handle seconds.milliseconds part\n    if (secondsPart.includes('.')) {\n      const [seconds, milliseconds] = secondsPart.split('.');\n      const totalMilliseconds = (minutes * 60 * 1000) +\n                               (parseInt(seconds, 10) * 1000) +\n                               parseInt(milliseconds.padEnd(3, '0').substring(0, 3), 10);\n      return totalMilliseconds;\n    } else {\n      // Only minutes:seconds format\n      const seconds = parseInt(secondsPart, 10);\n      return (minutes * 60 * 1000) + (seconds * 1000);\n    }\n  }\n\n  // If it's in seconds.milliseconds format\n  if (cleanGap.includes('.')) {\n    const [seconds, milliseconds] = cleanGap.split('.');\n    return (parseInt(seconds, 10) * 1000) + parseInt(milliseconds.padEnd(3, '0').substring(0, 3), 10);\n  }\n\n  // If it's just seconds\n  return parseFloat(cleanGap) * 1000;\n}\n"],
  "mappings": "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",
  "names": []
}
