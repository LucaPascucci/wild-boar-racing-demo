{
  "version": 3,
  "sources": ["src/app/lap-simulator/service/lap-simulator.worker.ts"],
  "sourcesContent": ["/// <reference lib=\"webworker\" />\n\nimport { ShadowLap } from \"../model/shadow-lap\";\nimport { LapSimulatorConfig } from \"../model/lap-simulator-config\";\nimport { FutureLap } from \"../model/future-lap\";\n\naddEventListener('message', ({ data }) => {\n  const cumulatedTimeByRaceNumber = data.cumulatedTimeByRaceNumber as Map<number, number[]>\n  const pacesByRaceNumber = data.pacesByRaceNumber as Map<number, number>;\n  const lastLapNumberByRaceNumber = data.lastLapNumberByRaceNumber as Map<number, number>\n  const lapSimulatorConfig = data.lapSimulatorConfig as LapSimulatorConfig;\n  const firstTeamRaceNumber = data.firstTeamRaceNumber as number | undefined;\n\n  const referenceRaceNumber = lapSimulatorConfig.referenceRaceNumber\n  const nextPitMilliseconds = lapSimulatorConfig.nextPitMilliseconds\n  const timeLostThroughPitMilliseconds = lapSimulatorConfig.timeLostThroughPitMilliseconds\n\n  const referenceRaceNumberAverageTime = calculateReferenceRaceNumberAverageTime(cumulatedTimeByRaceNumber, referenceRaceNumber)\n\n  const normalizedCumulatedTimeLaps = normalizeCumulatedTimeLaps(cumulatedTimeByRaceNumber, referenceRaceNumberAverageTime)\n\n  const shadowLaps = createShadows(\n      normalizedCumulatedTimeLaps,\n      referenceRaceNumberAverageTime,\n      referenceRaceNumber,\n      lastLapNumberByRaceNumber,\n  );\n\n  const futureLaps = simulateFutureLaps(\n    cumulatedTimeByRaceNumber,\n    pacesByRaceNumber,\n    lastLapNumberByRaceNumber,\n    referenceRaceNumberAverageTime,\n    lapSimulatorConfig\n  );\n\n  const futureLapsWithPitNow = createFutureLapsWithPitNow(\n    futureLaps,\n    nextPitMilliseconds,\n    timeLostThroughPitMilliseconds\n  );\n\n  const virtualLastCumulatedTimeByRaceNumber = calculateVirtualLastCumulatedTimeByRaceNumber(\n    firstTeamRaceNumber,\n    cumulatedTimeByRaceNumber,\n    lastLapNumberByRaceNumber,\n    pacesByRaceNumber\n  )\n\n  postMessage({\n    normalizedCumulatedTimeLaps: normalizedCumulatedTimeLaps,\n    shadowLaps: shadowLaps,\n    futureLaps: futureLaps,\n    futureLapsWithPitNow: futureLapsWithPitNow,\n    virtualLastCumulatedTimeByRaceNumber: virtualLastCumulatedTimeByRaceNumber\n  });\n});\n\ninterface TrackPosition {\n  raceNumber: number;\n  totalLapTimeMilliseconds: number;\n}\n\nfunction simulateFutureLaps(\n  cumulatedTimeByRaceNumber: Map<number, number[]>,\n  pacesByRaceNumber: Map<number, number>,\n  lastLapNumberByRaceNumber: Map<number, number>,\n  referenceRaceNumberAverageTime: number,\n  lapSimulatorConfig: LapSimulatorConfig\n): FutureLap[] {\n  const result: FutureLap[] = [];\n  const futureLaps = new Map<number, number[]>();\n\n  const cumulated = cumulatedTimeByRaceNumber;\n\n  for (let i = 0; i <= (lapSimulatorConfig.simulatedLaps - 1); i++) {\n    const raceNumbers = [...cumulatedTimeByRaceNumber.keys()]\n\n    const lastCumulatedTimeLap = getLastCumulatedTimeLap(cumulated);\n    const futureCumulatedTimeLap = generateFutureLastCumulatedTimeLap(lastCumulatedTimeLap, pacesByRaceNumber);\n\n    const currentTrackPositions = generateTrackPositions(lastCumulatedTimeLap);\n    const futureTrackPositions = generateTrackPositions(futureCumulatedTimeLap);\n\n    raceNumbers.forEach((raceNumber) => {\n\n      const futureCumulatedTimeLapRaceNumber = futureCumulatedTimeLap.get(raceNumber)\n      if (futureCumulatedTimeLapRaceNumber) {\n        cumulated.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n\n        if (!futureLaps.has(raceNumber)) {\n          const firstFutureLaps: number[] = [];\n          // NOTE: AGGIUNGO ANCHE L'ULTIMO VERO GIRO PER COLLEGARMI AL GRAFICO REALE\n          const lastCumulatedTimeLapByRaceNumber = lastCumulatedTimeLap.get(raceNumber);\n          if (lastCumulatedTimeLapByRaceNumber) {\n            firstFutureLaps.push(lastCumulatedTimeLapByRaceNumber);\n          }\n          firstFutureLaps.push(futureCumulatedTimeLapRaceNumber);\n          futureLaps.set(raceNumber, firstFutureLaps);\n        } else {\n          futureLaps.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n        }\n      }\n\n      /* const overtakes = calculateOvertakes(\n          currentTrackPositions,\n          futureTrackPositions,\n          raceNumber);*/\n\n      /*if (overtakes.overtakenRaceNumbers.length == 0 && overtakes.overtakenByRaceNumbers.length > 0) {\n        const futureCumulatedTimeLapRaceNumber = futureCumulatedTimeLap.get(raceNumber)\n        if (futureCumulatedTimeLapRaceNumber) {\n          cumulated.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n          if (!futureLaps.has(raceNumber)) {\n            futureLaps.set(raceNumber, [futureCumulatedTimeLapRaceNumber]);\n          }\n          futureLaps.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n        }\n      }*/\n\n      // Controllo se \u00E8 soddisfatta la condizione per il sorpasso effettuato o subito\n      // Questa condizione si basa sul confronto del pace dei race number coinvolti pi\u00F9 una soglia di 700 millisecondi.\n      /*\n      const raceNumberPace = paces.get(raceNumber) || 0;\n      const threshold = lapSimulatorConfig.overtakeThresholdMilliseconds;\n\n      // Ottieni il valore corrente del futureCumulatedTimeLap per il raceNumber\n      let futureCumulatedTimeLapRaceNumber = futureCumulatedTimeLap.get(raceNumber);\n      if (futureCumulatedTimeLapRaceNumber) {\n        let timeAdjustment = 0;\n\n        // Gestisci i sorpassi effettuati\n        for (const overtakenRaceNumber of overtakes.overtakenRaceNumbers) {\n          const overtakenRaceNumberPace = paces.get(overtakenRaceNumber) || 0;\n\n          // Verifica se il sorpasso \u00E8 realmente accaduto\n          // Il sorpasso \u00E8 accaduto se il pace del raceNumber \u00E8 pi\u00F9 veloce del pace del sorpassato di almeno threshold ms\n          if (raceNumberPace < overtakenRaceNumberPace - threshold) {\n            // Se il sorpasso \u00E8 soddisfatto, incrementa di 500 millisecondi\n            timeAdjustment += lapSimulatorConfig.toOvertakeLostTimeMilliseconds;\n          } else {\n            // Se il sorpasso non \u00E8 soddisfatto, decrementa della differenza di passo tra me e il race number non sorpassato\n            timeAdjustment -= (overtakenRaceNumberPace - raceNumberPace);\n          }\n        }\n\n        // Gestisci i sorpassi subiti\n        for (const overtakenByRaceNumber of overtakes.overtakenByRaceNumbers) {\n          const overtakenByRaceNumberPace = paces.get(overtakenByRaceNumber) || 0;\n\n          // Verifica se il sorpasso subito \u00E8 realmente accaduto\n          // Il sorpasso \u00E8 subito se il pace del raceNumber che ha sorpassato \u00E8 pi\u00F9 veloce del raceNumber di almeno threshold ms\n          if (overtakenByRaceNumberPace < raceNumberPace - threshold) {\n            // Se il sorpasso subito \u00E8 soddisfatto, incrementa di 1500 millisecondi\n            timeAdjustment += lapSimulatorConfig.beOvertakenLostTimeMilliseconds;\n          }\n        }\n\n        // Applica l'aggiustamento temporale al futureCumulatedTimeLap\n        futureCumulatedTimeLapRaceNumber += timeAdjustment;\n\n        // Aggiorna i risultati\n        cumulated.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n        if (!futureLaps.has(raceNumber)) {\n          futureLaps.set(raceNumber, [futureCumulatedTimeLapRaceNumber]);\n        } else {\n          futureLaps.get(raceNumber)?.push(futureCumulatedTimeLapRaceNumber);\n        }\n      }*/\n    });\n  }\n\n  futureLaps.forEach((laps, raceNumber) => {\n    const lastLapNumber = lastLapNumberByRaceNumber.get(raceNumber);\n    if (lastLapNumber) {\n      const startLapNumber = lastLapNumber;\n      const normalizedTimeLaps = normalizeTimeLaps(laps, referenceRaceNumberAverageTime, startLapNumber);\n      result.push({\n        startLapNumber: startLapNumber,\n        cumulatedTimeLaps: new Map<number, number[]>([\n            [raceNumber, normalizedTimeLaps]\n        ])\n      })\n    }\n  });\n\n  return result;\n}\n\n/**\n * Calculates which and how many race numbers a specific race number has overtaken\n * @param currentPositions Current track positions map (raceNumber \u2192 position)\n * @param futurePositions Future track positions map (raceNumber \u2192 position)\n * @param targetRaceNumber The race number being analyzed\n * @returns An object containing overtaken race numbers and count\n */\nfunction calculateOvertakes(\n    currentPositions: Map<number, number>,\n    futurePositions: Map<number, number>,\n    targetRaceNumber: number,\n): { overtakenRaceNumbers: number[], overtakenByRaceNumbers: number[] }  {\n  const overtakenRaceNumbers: number[] = [];\n  const overtakenByRaceNumbers: number[] = [];\n\n  // Get current and future positions for the target race number\n  const currentPosition = currentPositions.get(targetRaceNumber);\n  const futurePosition = futurePositions.get(targetRaceNumber);\n\n  // If position info is missing, return empty result\n  if (currentPosition === undefined || futurePosition === undefined) {\n    return { overtakenRaceNumbers: [], overtakenByRaceNumbers: [] };\n  }\n\n  // Iterate through all race numbers\n  currentPositions.forEach((position, raceNumber) => {\n    // Skip the target race number itself\n    if (raceNumber !== targetRaceNumber) {\n      const raceNumberFuturePosition = futurePositions.get(raceNumber);\n\n      // If the other race number has a valid future position\n      if (raceNumberFuturePosition !== undefined) {\n        // Case 1: The target race number has overtaken this race number\n        // This happens when:\n        // 1. The target race number was behind or equal in current positions\n        // 2. The target race number is ahead in future positions\n        if (currentPosition >= position && futurePosition < raceNumberFuturePosition) {\n          overtakenRaceNumbers.push(raceNumber);\n        }\n\n        // Case 2: This race number has overtaken the target race number\n        // This happens when:\n        // 1. The race number was behind or equal to target in current positions\n        // 2. The race number is ahead of target in future positions\n        if (position >= currentPosition && raceNumberFuturePosition < futurePosition) {\n          overtakenByRaceNumbers.push(raceNumber);\n        }\n      }\n    }\n  });\n  return { overtakenRaceNumbers, overtakenByRaceNumbers }\n}\n\n\nfunction getLastCumulatedTimeLap(cumulatedTimeLaps: Map<number, number[]>): Map<number, number> {\n  const result = new Map<number, number>();\n\n  cumulatedTimeLaps.forEach((cumulatedTimeLaps, raceNumber) => {\n    result.set(raceNumber, cumulatedTimeLaps[cumulatedTimeLaps.length - 1]);\n  });\n\n  return result;\n}\n\nfunction generateTrackPositions(lastCumulatedTimeLap: Map<number, number>): Map<number, number> {\n  const result = new Map<number, number>();\n\n  const trackPositions: TrackPosition[] = [];\n  lastCumulatedTimeLap.forEach((timeLap, raceNumber) => {\n    trackPositions.push({\n      raceNumber: raceNumber,\n      totalLapTimeMilliseconds: timeLap\n    })\n  });\n\n  // Sort the track positions by totalLapTimeMilliseconds (descending order)\n  trackPositions.sort((a, b) => b.totalLapTimeMilliseconds - a.totalLapTimeMilliseconds);\n\n  // Assign positions based on the sorted order\n  trackPositions.forEach((trackPosition, index) => {\n    result.set(trackPosition.raceNumber, index + 1);\n  });\n\n  return result;\n}\n\nfunction generateFutureLastCumulatedTimeLap(\n  lastCumulatedTimeLap: Map<number, number>,\n  pacesByRaceNumber: Map<number, number>\n): Map<number, number> {\n  const result = new Map<number, number>();\n\n  lastCumulatedTimeLap.forEach((lap, raceNumber) => {\n    const pace = pacesByRaceNumber.get(raceNumber) || 0;\n    result.set(raceNumber, lap + pace);\n  });\n\n  return result;\n}\n\nfunction calculateReferenceRaceNumberAverageTime(cumulatedTimeByRaceNumber: Map<number, number[]>, referenceRaceNumber: number) {\n  if (cumulatedTimeByRaceNumber.has(referenceRaceNumber)) {\n    const referenceRaceNumberCumulatedTimeLaps = cumulatedTimeByRaceNumber.get(referenceRaceNumber);\n    if (referenceRaceNumberCumulatedTimeLaps && referenceRaceNumberCumulatedTimeLaps.length > 0) {\n      return referenceRaceNumberCumulatedTimeLaps[referenceRaceNumberCumulatedTimeLaps.length - 1] / (referenceRaceNumberCumulatedTimeLaps.length - 1);\n    }\n    return 0\n  }\n  return 0;\n}\n\nfunction normalizeTimeLaps(laps: number[], referenceRaceNumberAverageTime: number, startLapNumber: number): number[] {\n  if (referenceRaceNumberAverageTime === 0) {\n    return laps;\n  }\n\n  return laps.map((lap, index) => {\n    const realLapNumber = startLapNumber + index;\n    return (realLapNumber * referenceRaceNumberAverageTime) - lap;\n  });\n}\n\nfunction normalizeCumulatedTimeLaps(cumulatedTimeByRaceNumber: Map<number, number[]>, referenceRaceNumberAverageTime: number): Map<number, number[]> {\n  if (referenceRaceNumberAverageTime === 0) {\n    return cumulatedTimeByRaceNumber;\n  }\n\n  const result = new Map<number, number[]>();\n\n  cumulatedTimeByRaceNumber.forEach((laps, raceNumber) => {\n    const normalizedLaps = normalizeTimeLaps(laps, referenceRaceNumberAverageTime, 0);\n    result.set(raceNumber, normalizedLaps);\n  });\n\n  return result;\n}\n\nfunction createShadows(\n    normalizedCumulatedTimeLaps: Map<number, number[]>,\n    referenceRaceNumberAverageTime: number,\n    referenceRaceNumber: number,\n    lastLapNumberByRaceNumber: Map<number, number>\n): ShadowLap[] {\n  const result: ShadowLap[] = [];\n  const referenceLapNumber = lastLapNumberByRaceNumber.get(referenceRaceNumber);\n\n  if (referenceLapNumber) {\n    normalizedCumulatedTimeLaps.forEach((laps, raceNumber) => {\n      if (referenceRaceNumber !== raceNumber) {\n        const lastLapNumberRaceNumber = lastLapNumberByRaceNumber.get(raceNumber);\n        if (lastLapNumberRaceNumber && lastLapNumberRaceNumber !== referenceLapNumber) {\n          const shadowLapNumber = referenceLapNumber - lastLapNumberRaceNumber;\n          const shadowLaps = createShadow(laps, referenceRaceNumberAverageTime, shadowLapNumber);\n\n          result.push({\n            cumulatedTimeLaps: new Map<number, number[]>([\n              [raceNumber, shadowLaps]\n            ]),\n            startLapNumber: shadowLapNumber >= 0 ? shadowLapNumber : 0\n          })\n        }\n      }\n    });\n  }\n\n  return result;\n}\n\nfunction createShadow(laps: number[], referenceRaceNumberAverageTime: number, shadowLapNumber: number): number[] {\n  let result: number[] = [];\n\n  if (shadowLapNumber < 0) {\n    laps = laps.slice(Math.abs(shadowLapNumber));\n  }\n\n  laps.forEach(lap => {\n    result.push(lap + (referenceRaceNumberAverageTime * shadowLapNumber));\n  })\n\n  return result;\n}\n\nfunction createFutureLapsWithPitNow(\n  futureLaps: FutureLap[],\n  nextPitMilliseconds: number,\n  timeLostThroughPitMilliseconds: number\n): FutureLap[] {\n\n  const result: FutureLap[] = [];\n\n  futureLaps.forEach(futureLap => {\n    const startLapNumber = futureLap.startLapNumber;\n    const translatedCumulatedTimeLaps = new Map<number, number[]>();\n    futureLap.cumulatedTimeLaps.forEach((laps, raceNumber) => {\n      const translatedLaps: number[] = [];\n      for (let i = 0; i < laps.length; i++) {\n        if (i === 0) {\n          translatedLaps.push(laps[i]);\n        } else {\n          translatedLaps.push(laps[i] - (nextPitMilliseconds + timeLostThroughPitMilliseconds));\n        }\n      }\n      translatedCumulatedTimeLaps.set(raceNumber, translatedLaps);\n    });\n\n    result.push({\n      startLapNumber: startLapNumber,\n      cumulatedTimeLaps: translatedCumulatedTimeLaps\n    });\n  });\n\n  return result;\n}\n\nfunction calculateVirtualLastCumulatedTimeByRaceNumber(\n  firstTeamRaceNumber: number | undefined,\n  cumulatedTimeByRaceNumber: Map<number, number[]>,\n  lastLapNumberByRaceNumber: Map<number, number>,\n  pacesByRaceNumber: Map<number, number>,\n): Map<number, number> {\n  const result = new Map<number, number>();\n\n  if (!firstTeamRaceNumber) {\n    return result;\n  }\n  const firstTeamLastLapNumber = lastLapNumberByRaceNumber.get(firstTeamRaceNumber);\n\n  for (const [raceNumber, cumulatedTimes] of cumulatedTimeByRaceNumber) {\n    if (raceNumber === firstTeamRaceNumber) {\n      if (cumulatedTimes.length > 0) {\n        result.set(raceNumber, cumulatedTimes[cumulatedTimes.length - 1]);\n      }\n    } else {\n      const lastLap = lastLapNumberByRaceNumber.get(raceNumber);\n      if (lastLap === firstTeamLastLapNumber) {\n        if (cumulatedTimes.length > 0) {\n          result.set(raceNumber, cumulatedTimes[cumulatedTimes.length - 1]);\n        }\n      } else {\n        const pace = pacesByRaceNumber.get(raceNumber);\n        if (pace && firstTeamLastLapNumber && lastLap) {\n          const missingLaps = firstTeamLastLapNumber - lastLap;\n          if (missingLaps > 0 && cumulatedTimes.length > 0) {\n            const virtualMisingTime = missingLaps * pace;\n            const lastCumulatedTime = cumulatedTimes[cumulatedTimes.length - 1] || 0;\n            const virtualLastCumulatedTime = lastCumulatedTime + virtualMisingTime;\n            result.set(raceNumber, virtualLastCumulatedTime);\n          }\n        }\n      }\n    }\n  }\n  return result;\n}\n"],
  "mappings": "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",
  "names": ["cumulatedTimeLaps"]
}
